/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package lvc.cds;

import java.util.HashMap;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import java.io.*;
import java.util.*;

public class KVS {
    private HashMap<String, JSONObject> kvs;
    
    /**
     * Generates an empty KVS
     */
    public KVS() {
       kvs = new HashMap<String,JSONObject>();
    }
    /**
     * Takes in filepath (.txt or .json). Converts file contents to data that is stored in KVS
     * @param InputFilePath
     * @throws FileNotFoundException
     */
    public void readInFile(String InputFilePath) throws FileNotFoundException{
        var parser = new JSONParser();
        var reader = new FileReader(InputFilePath);
        try {
            var obj = parser.parse(reader);
            var array = (JSONArray) obj;
            for(int i = 0; i<array.size();i++){
                var j = (JSONObject) array.get(i);
                var k = j.keySet().toArray();
                var key = Arrays.copyOf(k, k.length,String[].class);
                var v = j.values().toArray();
                var values = Arrays.copyOf(v, v.length,JSONObject[].class);
                add(key[0],values[0]);
                
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (ParseException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }  
    }

    /**
     * Writes KVS out to storage. Can either be a .txt or .json file.
     * @param outputFilePath
     */
    public void writeOutFile(String outputFilePath){
        try {
            File file = new File(outputFilePath);
            // create new BufferedWriter for the output file
            BufferedWriter bf = new BufferedWriter(new FileWriter(file));
            if(getSize()==0){
                bf.write("The KVS was empty");
                bf.flush();
                bf.close();
            }
            else{
                // iterate map entries

                var k = kvs.keySet();
                var arr = k.toArray();
                var keys = Arrays.copyOf(arr, arr.length,String[].class);

                bf.write("[");

                for (int i =0; i<keys.length-1; i++) {
  
                // put key and value separated by a colon
                    var obj = new JSONObject();
                    obj.put(keys[i],getValue(keys[i]));
                    bf.write(obj.toJSONString()+",");
  
                // new line
                    bf.newLine();
                    bf.newLine();
                }
                var json = new JSONObject();
                json.put(keys[keys.length-1],getValue(keys[keys.length-1]));
                bf.write(json.toJSONString()+"]");
            
                bf.flush();
                bf.close();
            }
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Clears KVS contents from memory
     */
    public void clear() {
        kvs.clear();
    }

    /**
     * Checks whether a given key is in the KVS
     * @param key the key that is being searched for
     * @return a boolean that states whether or not the string key is in the list of keys
     */
    public boolean containsKey(String key) {
        return kvs.containsKey(key);
    }

    /**
     * Returns the value corresponding to the given key or null if the key is not present
     * @param key the key that is being used to search for the value
     * @return the JSONObject corresponding to the given key.
     */
    public JSONObject getValue(String key){
        return kvs.get(key);
    }

    /**
     * Sets the given key to a new specified value
     * @param key the key that corresponding to the value that would like to be replaced
     * @param json the new desired JSONObject for the given key.
     * @return the new JSONObject or null if the given key is not present
     */
    public JSONObject setValue(String key, JSONObject json){
        return kvs.replace(key, json);
    } 

    /**
     * Adds the given key and JSONObject pair to the KVS.
     * @param key the given key string
     * @param json the JSONObject to correspond with the given key
     * @return null unless the given key was already in use, then the previous JSONObject corresponding to that key is returned.
     */
    public JSONObject add(String key, JSONObject json) {
        return kvs.put(key, json);
    }

   /**
    * Generates a KVS that contains all key value pairs where the keys contain the given regular expression
    * @param regex a string regular expression to search for in the keys.
    * @return a KVS
    */
    public KVS filter(String regex) {
        var ret = new KVS();
        var list = new ArrayList<String>(kvs.keySet());
        for (String k: list) {
            Pattern pattern = Pattern.compile(regex);
            Matcher m = pattern.matcher(k);
            if(m.matches()){
                var v = kvs.get(k);
                ret.add(k, v);
            }
        }
        return ret;
    }

    /**
     * Gets the size of the KVS
     * @return an integer that expresses the number of pairs in the KVS
     */
    public int getSize(){
        return kvs.size();
    }


}
